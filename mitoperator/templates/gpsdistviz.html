<html>
<head>
  <script src="/js/processing.js"></script>
  <script src="/js/jquery.js"></script>
  </head>
  <h2>Distance from trip start vs. time since schedule start</h2>
  <p><canvas id="canvas1" width="400" height="400"></canvas></p>
  <div id="prediction"></div>
  <h2>Distance from start vs. speed</h2>
  <p><canvas id="canvas2" width="400" height="400"></canvas></p>

  <script id="script1" type="text/javascript">

  var trip_stat_data=null;
  var hypotheticals=null;

  // scale the canvas
  var xres=1;
  var yres_time=1;
  var mindist=0;
  var maxtime=0;
  var mintime=0;
  var maxtime=0;

  var waitmode=false;

  $(document).ready(function(){

  function sketchProc(processing) {

    var draw_hypotheticals = function(data) {

        var paths = data[0];

        p.stroke( 255,0,0 )
        p.strokeWeight( 1 )
        for(j=0; j<paths.length; j++) {
          var path = paths[j];
          for(i=0; i<path.length-1; i++) {
            var d1 = path[i][0];
            var t1 = path[i][1];
            var d2 = path[i+1][0];
            var t2 = path[i+1][1];

            p.line( d1, t1, d2, t2 );
          }
        }

        p.stroke(0,0,255);
        p.strokeWeight(5);
        var quadrant_paths = data[1];
        for(j=0; j<quadrant_paths.length; j++) {
          var path = quadrant_paths[j];
          for(i=0; i<path.length-1; i++) {
            var d1 = path[i][0];
            var t1 = path[i][1];
            var d2 = path[i+1][0];
            var t2 = path[i+1][1];

            p.line( d1, t1, d2, t2 );
          }
        }
    };

    processing.setup = function() {
      processing.size( 1200,600 );
    }

    // Override draw function, by default it will be called 60 times per second
    processing.draw = function() {
        if(waitmode) {
            black = Math.floor(processing.frameCount/processing.width)%2==0;
            //console.log( Math.round(processing.frameCount/processing.width)%2 );
            if(black){
                processing.stroke(0);
            } else {
                processing.stroke(255);
            }
            processing.line(processing.frameCount%processing.width,2*processing.height/5,processing.frameCount%processing.width,3*processing.height/5);
        }
    };

    var interpolate_and_draw_distance = function(line, tt) {

        for(i=0; i<line.length-1; i++){
          dd1 = line[i][0];
          tt1 = line[i][1];
          dd2 = line[i+1][0];
          tt2 = line[i+1][1];

          if( tt1<=tt && tt2>=tt ) {
            dd_interp = ((tt-tt1)/(tt2-tt1))*(dd2-dd1)+dd1;
            processing.line( dd_interp, tt, dd_interp, 0 );
            return dd_interp;
          }
        }
    }

    var interpolate_and_draw_time = function(line, dd) {

        for(i=0; i<line.length-1; i++){
          dd1 = line[i][0];
          tt1 = line[i][1];
          dd2 = line[i+1][0];
          tt2 = line[i+1][1];

          if( dd1<=dd && dd2>=dd ) {
            tt_interp = ((dd-dd1)/(dd2-dd1))*(tt2-tt1)+tt1;
            processing.line( dd, tt_interp, 0, tt_interp );
            return tt_interp;
          }
        }
    }

    processing.mouseClicked = function() {
      var tt = ((processing.height-processing.mouseY)/yres_time+mintime);
      var dd = processing.mouseX/xres;

      if( processing.mouseX < 10 ) {

        draw_trip_stats( trip_stat_data, false );
        draw_hypotheticals(hypotheticals);

        fitlines = hypotheticals[1];

        processing.stroke(0,255,0);
        processing.strokeWeight(3);

        lowest_dd=interpolate_and_draw_distance(fitlines[0], tt);
        probable_dd=interpolate_and_draw_distance(fitlines[1], tt);
        highest_dd=interpolate_and_draw_distance(fitlines[2], tt );

        processing.line(mindist, tt, maxdist, tt);

        $("#prediction").html("At time "+Math.round(tt)+"s, between "+Math.round(lowest_dd)+"m and "+Math.round(highest_dd)+"m, P(0.5) at "+Math.round(probable_dd)+"m");
        return;
      }

      if( Math.abs(tt)*yres_time < 15 ){
        draw_trip_stats( trip_stat_data, false );
        draw_hypotheticals(hypotheticals);

        fitlines = hypotheticals[1];

        processing.stroke(0,255,0);
        processing.strokeWeight(3);

        earliest_tt=interpolate_and_draw_time(fitlines[0], dd);
        probable_tt=interpolate_and_draw_time(fitlines[1], dd);
        latest_tt=interpolate_and_draw_time(fitlines[2], dd);

        processing.line(dd, mintime, dd, maxtime);
        $("#prediction").html("At distance "+Math.round(dd)+"m, between "+Math.round(100*earliest_tt/60)/100+"min and "+Math.round(100*latest_tt/60)/100+"min, P(0.5) at "+Math.round(100*probable_tt/60)/100+"min");
        return;
      }

      $.getJSON( '{% url pathsamples %}?trip_id='+current_trip_id+'&dd='+dd+'&tt='+tt, function(data){
        draw_trip_stats( trip_stat_data, false );

        hypotheticals=data;
        draw_hypotheticals(hypotheticals);
      } );
    }
                                                                                                          
  }

  function sketchProc2(processing) {

    processing.setup = function() {
      processing.size( 1200,600 );
    }

    // Override draw function, by default it will be called 60 times per second
    processing.draw = function() {
    };

    processing.mouseClicked = function() {
      $.getJSON( '{% url speedsamples %}?trip_id='+current_trip_id, function(data) {
        var resolution = data[0];
        var samples = data[1];

        p2.stroke( 255,0,0 );
        for(i=0; i<samples.length-1; i++){
            var d1 = i*resolution;
            var v1 = samples[i];
            var d2 = (i+1)*resolution;
            var v2 = samples[i+1];

            p2.line( d1, v1*yscale, d2, v2*yscale );
                
        }
      } );
    }
                                                                                                          
  }

  var canvas = document.getElementById("canvas1");
  var canvas2 = document.getElementById("canvas2");
  // attaching the sketchProc function to the canvas
  var p = new Processing(canvas, sketchProc);
  var p2 = new Processing(canvas2, sketchProc2);
  p2.background( 255,250,250 );
  p.background( 250 );

  var draw_trip_stats = function(data, scale) {

        p2.background( 255,250,250 );
        p.background( 250 );

        trip_data = data;

        current_trip_id = trip_data.trip_id;

        // find global min and global max
        mintime = 1000000;
        maxtime = -1000000;
        mindist = 1000000;
        maxdist = -1000000;

        minspeed = 0;
        maxspeed = 26;

        $.each( trip_data.run_data, function( key, val ) {

          ptlist = val[1];
          for(var i=0; i< ptlist.length-1; i++) {
            pt1 = ptlist[i];
            pt2 = ptlist[i+1];

            time1 = pt1[0];
            dist1 = pt1[2];
            time2 = pt2[0];
            dist2 = pt2[2];

            if( time1 < mintime ) {
                mintime = time1;
            }
            if( time2 > maxtime ) {
                maxtime = time2;
            }
            if( dist1 < mindist ) {
                mindist = dist1;
            }
            if( dist2 > maxdist ) {
                maxdist = dist2;
            }
          }
        } );

        // scale the canvas
        xres = p.width/(maxdist-mindist);
        yres_time = p.height/(maxtime-mintime);

        if(scale){
          p.scale( xres, -yres_time );
          p.translate( -mindist, -maxtime );
        }

        // set up the tick marks
        p.stroke( 255, 0, 0 );
        p.strokeWeight(1);
        // axes
        p.line(mindist, 0, maxdist, 0);
        p.line(mindist, mintime, mindist, maxtime);

        // distance ticks
        distspace = 40;
        for(var x=mindist; x<=maxdist; x+=distspace){
          p.line( x, 0, x, 50 );
        }
        // time ticks
        timespace = 60;
        for(var y=0; y<=maxtime; y+=timespace){
          p.line( mindist, y, mindist+50, y );
        }

        // draw the timelines
        p.stroke( 0 );
        $.each( trip_data.run_data, function( key, val ) {

          ptlist = val[1];
          for(var i=0; i< ptlist.length-1; i++) {
            pt1 = ptlist[i];
            pt2 = ptlist[i+1];

            time1 = pt1[0];
            dist1 = pt1[2];
            time2 = pt2[0];
            dist2 = pt2[2];
            p.line( dist1, time1, dist2, time2 );
          }
        } );
       
        //==========SPEED PLOT===============

        yscale = 100;

        // scale the canvas
        xres = p2.width/(maxdist-mindist);
        yres = p2.height/(maxspeed*yscale-minspeed*yscale);

        if(scale){
          p2.scale( xres, -yres );
          p2.translate( -mindist, -maxspeed*yscale );
        }

        // set up the tick marks
        p2.stroke( 255, 0, 0 );
        // axes
        p2.line(mindist, 0, maxdist, 0);
        p2.line(mindist, minspeed*yscale, mindist, maxspeed*yscale);

        // distance ticks
        distspace = 40;
        for(var x=mindist; x<=maxdist; x+=distspace){
          p2.line( x, 0, x, 50 );
        }
        // speed ticks
        speedspace = 1;
        for(var y=0; y<=maxspeed*yscale; y+=speedspace*yscale){
          p2.line( mindist, y, mindist+50, y );
        }

        // draw the speed plots
        p2.stroke( 128 );
        p2.strokeWeight(1)
        $.each( trip_data.run_data, function( key, val ) {

          vs_plot = val[2];
          pitch = vs_plot[0]; // distance between velocity measurements
          vs = vs_plot[1]; // plot of velocities
          for(var i=0; i< vs.length-1; i++) {
            v1 = vs[i];
            v2 = vs[i+1];

            d1 = i*pitch;
            d2 = (i+1)*pitch;

            p2.line( d1, v1*yscale, d2, v2*yscale );
          }
        } );

        //===========MEAN SPEED PLOT===========
        p2.stroke( 0,0,255 );
        p2.strokeWeight( 10 );
        pitch = trip_data.mean_speed[0]; // distance between velocity measurements
        vs = trip_data.mean_speed[1]; // plot of velocities
        for(var i=0; i< vs.length-1; i++) {
          d1 = i*pitch;
          d2 = (i+1)*pitch;

          // 5th percentile
          v1 = vs[i][0];
          v2 = vs[i+1][0];

          if( v1 && v2 ){
            p2.strokeWeight(3);
            p2.line( d1, v1*yscale, d2, v2*yscale );
          }
         
          // 50th percentile
          v1 = vs[i][1];
          v2 = vs[i+1][1];

          if( v1 && v2 ){
            p2.strokeWeight(10);
            p2.line( d1, v1*yscale, d2, v2*yscale );
          }

          // 95th percentile
          v1 = vs[i][2];
          v2 = vs[i+1][2];

          if( v1 && v2 ){
            p2.strokeWeight(3);
            p2.line( d1, v1*yscale, d2, v2*yscale );
          }
        }
    }

  var onclickme = function() {
    waitmode = true; $("#predition").html("It usually takes a few minutes...");
    $.getJSON('{% url gpsdistances %}?trip_id={{trip_id}}{% if nocache%}&nocache={{nocache}}{%endif%}{%if fittype%}&fittype={{fittype}}{%endif%}', function(data) {
       waitmode= false; $("#prediction").html("");
       trip_stat_data = data;

       draw_trip_stats(trip_stat_data, true);
    })
  } 

  onclickme();

  p.stroke( 0 );

  // p.exit(); to detach it
  
  });
  
  </script>

<div style="height:0px;width:0px;overflow:hidden;"></div>


